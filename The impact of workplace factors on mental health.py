# -*- coding: utf-8 -*-
"""CS577 Semester Project

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/124F2aAnLJOrp_taWsJHzPM3ecHodGFD0

Objective question: understand what are the factors contributing the mental health of a person in the tech industry. See if benefits have a high correlation to other variables

# **Understanding the columns**

Timestamp

Age

Gender

Country

state: If you live in the United States, which state or territory do you live in?

self_employed: Are you self-employed?

family_history: Do you have a family history of mental illness?

treatment: Have you sought treatment for a mental health condition?

work_interfere: If you have a mental health condition, do you feel that it interferes with your work?

no_employees: How many employees does your company or organization have?

remote_work: Do you work remotely (outside of an office) at least 50% of the time?

tech_company: Is your employer primarily a tech company/organization?

benefits: Does your employer provide mental health benefits?

care_options: Do you know the options for mental health care your employer provides?

wellness_program: Has your employer ever discussed mental health as part of an employee wellness program?

seek_help: Does your employer provide resources to learn more about mental health issues and how to seek help?

anonymity: Is your anonymity protected if you choose to take advantage of mental health or substance abuse treatment resources?

leave: How easy is it for you to take medical leave for a mental health condition?

mental_health_consequence: Do you think that discussing a mental health issue with your employer would have negative consequences?

phys_health_consequence: Do you think that discussing a physical health issue with your employer would have negative consequences?

coworkers: Would you be willing to discuss a mental health issue with your coworkers?

supervisor: Would you be willing to discuss a mental health issue with your direct supervisor(s)?

mental_health_interview: Would you bring up a mental health issue with a potential employer in an interview?

phys_health_interview: Would you bring up a physical health issue with a potential employer in an interview?

mental_vs_physical: Do you feel that your employer takes mental health as seriously as physical health?

obs_consequence: Have you heard of or observed negative consequences for coworkers with mental health conditions in your workplace?

comments: Any additional notes or comments
"""

import pandas as pd
import matplotlib.pyplot as plt
import matplotlib
import seaborn as sns
import numpy as np
from sklearn.preprocessing import LabelEncoder
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.linear_model import LogisticRegression
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier
from sklearn.svm import SVC
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score

# Load the CSV data into a DataFrame
df = pd.read_csv('survey.csv')

# Display the first few rows of the DataFrame
df.head()

"""We will be dropping the timestamp column because it's contains date, month, year and time the respondent took this questionnaire, which is irrelevant for us."""

# Print how many respondants from each country
print(df['Country'].value_counts())
print("\n \n")

"""We will also be dropping the country and state column because there is not enough respondents from each country to conclude if their country faces bigger mental health issues compared to other countries therefore it becomes irrelevant. Thus, the state column also becomes irrelavent because that column is only relevant to the US. We will also be dropping the comments column because it is an optional question and many decided to forego answering it."""

# Drop timestamp, country, state, and comments columns
df.drop(columns=['Timestamp', 'Country', 'state', 'comments'], inplace = True)

"""Look for values that don't make sense or are outliers for the age column. I am setting the limit from 18-72."""

# Get unique values and their counts from the 'age' column
age_counts = df['Age'].value_counts()

# Print the counts
print(age_counts)

# Filter out age outliers
df = df[(df['Age'] >= 18) & (df['Age'] <= 100)]

# Print the filtered age counts to verify
filtered_age_counts = df['Age'].value_counts()
print(filtered_age_counts)

"""Let's look at genders."""

# Prints all unique gender variables
print(df['Gender'].unique())

"""We see that there was most likely no dropbox option for this question because there were many different unique values. I will be cleaning this up to be Male, Female, and other."""

# Create a copy of the DataFrame
clean_df = df.copy()

# Replace the gender values for 'Male'
clean_df['Gender'].replace(['Male ', 'male', 'M', 'm', 'Male', 'Cis Male',
                           'Man', 'cis male', 'Mail', 'Male-ish', 'Male (CIS)',
                           'Cis Man', 'msle', 'Malr', 'Mal', 'maile', 'Make'], 'Male', inplace=True)

# Replace the gender values for 'Female'
clean_df['Gender'].replace(['Female ', 'female', 'F', 'f', 'Woman', 'Female',
                           'femail', 'Cis Female', 'cis-female/femme', 'Femake', 'Female (cis)',
                           'woman'], 'Female', inplace=True)

# Replace the gender values for 'Other'
clean_df['Gender'].replace(['Female (trans)', 'queer/she/they', 'non-binary',
                           'fluid', 'queer', 'Androgyne', 'Trans-female', 'male leaning androgynous',
                           'Agender', 'A little about you', 'Nah', 'All',
                           'ostensibly male, unsure what that really means',
                           'Genderqueer', 'Enby', 'p', 'Neuter', 'something kinda male?',
                           'Guy (-ish) ^_^', 'Trans woman'], 'Other', inplace=True)

# Count the occurrences of each category
gender_counts = clean_df['Gender'].value_counts()
print(gender_counts)

"""We must now look at null values."""

# Count null values for each column
clean_df.isnull().sum()

"""I will be replacing self_employed null values to "No" because only 1.4% are self employed so it is safe to assume that. I will be replacing work_interfere null values to "Don't know."
"""

# Replace null values in 'self_employed' with 'No'
clean_df['self_employed'].fillna('No', inplace=True)

# Replace null values in 'work_interfere' with 'Don't know'
clean_df['work_interfere'].fillna("Don't know", inplace=True)

# Verify changes by checking for null values
clean_df.isnull().sum()

"""# **Plotting Treatment vs No Treatment because that is our target variable**"""

# Count the number of responses for treatment
treatment_counts = clean_df['treatment'].value_counts()

# Plotting the bar chart
colors = ['#6a994e', '#bc4749']  # Green for 'Yes', Red for 'No'
treatment_counts.plot(kind='bar', color=colors, figsize=(8, 5))
plt.title('Treatment vs. No Treatment')
plt.xlabel('Treatment')
plt.ylabel('Count')
plt.xticks(rotation=0)  # Rotate labels to horizontal
plt.show()

"""## We will now analyze each column and make assumptions based on what we find."""

# Change default font to Serif
matplotlib.rcParams['font.family'] = 'serif'

for column in clean_df.columns:
    if clean_df[column].dtype == 'object':  # Filtering for categorical columns
        # Group the data by the categorical column and 'treatment' status
        grouped = clean_df.groupby([column, 'treatment']).size().unstack(fill_value=0)

        # Reverse the order of stacking by sorting the columns if both 'Yes' and 'No' are present
        if 'Yes' in grouped.columns and 'No' in grouped.columns:
            grouped = grouped[['Yes', 'No']]
        colors = ['#6a994e', '#bc4749']  # 'Yes' in green and 'No' in red

        # Create a stacked bar plot with specified colors
        ax = grouped.plot(kind='bar', stacked=True, color=colors, figsize=(10, 6))

        # Calculate the total counts for each category to find percentages
        totals = grouped.sum(axis=1)

        # Annotate percentages for 'Yes' treatment sought
        for i, (name, row) in enumerate(grouped.iterrows()):
            if 'Yes' in row.index:  # Check if 'Yes' category exists for treatment
                value = row['Yes']
                pct = f"{(value / totals[name] * 100):.1f}%"  # Calculate percentage
                x = i
                y = value / 2  # Position for annotation in the middle of the 'Yes' section
                ax.text(x, y, pct, ha='center', va='center', color='white')  # White text for visibility

        # Customize the plot
        plt.title(f'{column} by Treatment Status')
        plt.xlabel(column)
        plt.ylabel('Count')
        plt.xticks(rotation=45)
        plt.legend(title='Treatment Sought', loc='upper right')
        plt.tight_layout()

        # Show the plot
        plt.show()

# Print each unique value for each column
list_col=['Age', 'Gender', 'self_employed', 'family_history', 'treatment',
       'work_interfere', 'no_employees', 'remote_work', 'tech_company',
       'benefits', 'care_options', 'wellness_program', 'seek_help',
       'anonymity', 'leave', 'mental_health_consequence',
       'phys_health_consequence', 'coworkers', 'supervisor',
       'mental_health_interview', 'phys_health_interview',
       'mental_vs_physical', 'obs_consequence']

for col in list_col:
    print('{} :{} ' . format(col.upper(),clean_df[col].unique()))

# Select categorical columns
categorical_columns = clean_df.select_dtypes(include=['object']).columns

# Initialize LabelEncoder
label_encoder = LabelEncoder()

# Label encode categorical columns
for col in categorical_columns:
    clean_df[col] = label_encoder.fit_transform(clean_df[col])

# Now clean_df contains label encoded categorical columns
clean_df

# Calculate the correlation matrix
correlation_matrix = clean_df.corr()

# Generate a mask for the upper triangle
mask = np.triu(np.ones_like(correlation_matrix, dtype=bool))

# Generate the heatmap with custom colormap and annotations
plt.figure(figsize=(12, 10))
sns.heatmap(correlation_matrix, mask=mask, annot=True, fmt=".2f", cmap='Greens', square=True,
            annot_kws={"size": 8})  # Set the font size to 8

# Add titles and labels
plt.title('Correlation Matrix Heatmap')
plt.xticks(rotation=45, ha='right')
plt.yticks(rotation=0)
plt.tight_layout()

# Show the plot
plt.show()

# Step 1: Data Preparation
features = ['work_interfere', 'benefits', 'care_options']
X = clean_df[features]
y = clean_df['treatment']

# Step 2: Split the Data
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Step 3: Choose Models
models = {
    'Logistic Regression': LogisticRegression(),
    'Decision Tree': DecisionTreeClassifier(),
    'Random Forest': RandomForestClassifier(),
    'Gradient Boosting': GradientBoostingClassifier(),
    'SVM': SVC()
}

# Step 4: Train and Evaluate Models
results = {}
for name, model in models.items():
    model.fit(X_train, y_train)
    y_pred = model.predict(X_test)
    accuracy = accuracy_score(y_test, y_pred)
    precision = precision_score(y_test, y_pred)
    recall = recall_score(y_test, y_pred)
    f1 = f1_score(y_test, y_pred)
    results[name] = {'Accuracy': accuracy, 'Precision': precision, 'Recall': recall, 'F1-score': f1}

# Display results
results_df = pd.DataFrame(results).T
print(results_df)

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.tree import DecisionTreeClassifier, plot_tree
import matplotlib.pyplot as plt

features = ['work_interfere', 'benefits', 'care_options']
X = clean_df[features]
y = clean_df['treatment']

# Split the data
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Train the Decision Tree Model
decision_tree_model = DecisionTreeClassifier(max_depth=3)
decision_tree_model.fit(X_train, y_train)

# Visualize the tree
plt.figure(figsize=(100, 100), dpi=200)  # Larger and higher resolution
plot_tree(decision_tree_model, filled=True, feature_names=features, class_names=['No Treatment', 'Treatment'])
plt.title('Decision Tree for Predicting Mental Health Treatment')
plt.show()
